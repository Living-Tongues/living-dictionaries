CREATE TABLE sentences (
  id uuid unique primary key NOT NULL, -- generated on client so users can create a sentence offline and keep editing it
  "text" text,
  translation jsonb,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  created_by uuid NOT NULL REFERENCES auth.users (id),
  updated_at timestamp with time zone DEFAULT now() NOT NULL,
  updated_by uuid NOT NULL REFERENCES auth.users (id),
  deleted timestamp with time zone
);

ALTER TABLE sentences ENABLE ROW LEVEL SECURITY;

CREATE TABLE senses_in_sentences (
  sense_id uuid NOT NULL REFERENCES senses (id),
  sentence_id uuid NOT NULL REFERENCES sentences (id),
  created_by uuid NOT NULL REFERENCES auth.users (id),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  deleted timestamp with time zone,
  PRIMARY KEY (sense_id, sentence_id)
);

ALTER TABLE senses_in_sentences ENABLE ROW LEVEL SECURITY;

CREATE TYPE sentence_tables AS ENUM ('sentences', 'senses_in_sentences');
CREATE TYPE sentence_columns AS ENUM ('deleted', 'text', 'translation');

CREATE TABLE sentence_updates (
  id uuid unique primary key NOT NULL, -- generated by client via uuidv4 so it can be idempotent and they can send it multiple times without repeated effect in case of network issues
  user_id uuid NOT NULL REFERENCES auth.users (id),
  firebase_email text, -- temporary until migration complete
  dictionary_id text NOT NULL REFERENCES dictionaries (id),
  sentence_id uuid NOT NULL REFERENCES sentences (id),
  sense_id uuid REFERENCES senses (id), -- could be null, but if included the apply_sentence_updates trigger will create a sense-sentence relationship
  "timestamp" timestamp with time zone NOT NULL DEFAULT now(),
  "table" sentence_tables NOT NULL,
  -- all following could be null if just adding a new sense-sentence relationship using senses_in_sentences table
  "column" sentence_columns, 
  new_value text, 
  old_value text
);

ALTER TABLE sentence_updates ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION ensure_dictionary_before_apply_sentence_updates()
RETURNS TRIGGER AS $$
DECLARE
  column_data_type regtype;
  dictionary_exists boolean;
BEGIN
  INSERT INTO dictionaries (id) VALUES (NEW.dictionary_id) ON CONFLICT DO NOTHING;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER before_on_sentence_updates_temp1 -- will fire before the next trigger because postgres executes triggers in alphabetical order
BEFORE INSERT ON sentence_updates
FOR EACH ROW 
EXECUTE FUNCTION ensure_dictionary_before_apply_sentence_updates();

-- After migrating dictionaries we can run:
-- DROP TRIGGER if exists before_on_sentence_updates_temp1 ON sentence_updates;
-- DROP FUNCTION if exists ensure_dictionary_before_apply_sentence_updates();

CREATE OR REPLACE FUNCTION convert_firebase_email_to_supabase_user_id_using_field()
RETURNS TRIGGER AS $$
DECLARE
    fetched_user_id UUID;
BEGIN
    SELECT id INTO fetched_user_id
    FROM auth.users
    WHERE email = NEW.firebase_email;

    IF fetched_user_id IS NOT NULL THEN
        NEW.user_id := fetched_user_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER before_on_sentence_updates_temp2
BEFORE INSERT ON sentence_updates
FOR EACH ROW 
EXECUTE FUNCTION convert_firebase_email_to_supabase_user_id_using_field();

CREATE OR REPLACE FUNCTION apply_sentence_updates()
RETURNS TRIGGER AS $$
DECLARE
  column_data_type regtype;
BEGIN
  IF NEW.table = 'sentences' THEN
  
    SELECT atttypid::regtype INTO column_data_type
    FROM pg_attribute
    WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'sentences')
      AND attname = NEW.column::text;

    EXECUTE format(
      'INSERT INTO sentences 
      (id, %I, created_by, updated_by, created_at, updated_at) 
      VALUES ($1::uuid, $2::%s, $3, $3, now(), now()) 
      ON CONFLICT (id) DO UPDATE 
      SET %I = $2::%s, updated_by = $3, updated_at = now()', 
      NEW.column,
      column_data_type,
      NEW.column,
      column_data_type
    ) USING NEW.sentence_id, NEW.new_value, NEW.user_id;

    IF NEW.sense_id IS NOT NULL THEN
      INSERT INTO senses_in_sentences -- ensure sense-sentence relationship exists
      (sense_id, sentence_id, created_by, created_at) 
      VALUES (NEW.sense_id, NEW.sentence_id, NEW.user_id, now()) 
      ON CONFLICT (sense_id, sentence_id) DO NOTHING;
    END IF;

  ELSIF NEW.table = 'senses_in_sentences' THEN -- sentence_updates only target this table if they are removing a sentence from a sense or adding sentence to additional senses

    IF NEW.column = 'deleted' THEN
      UPDATE senses_in_sentences 
      SET deleted = now() 
      WHERE sense_id = NEW.sense_id AND sentence_id = NEW.sentence_id;
    ELSE
      INSERT INTO senses_in_sentences -- add this sense to existing sentence
      (sense_id, sentence_id, created_by, created_at) 
      VALUES (NEW.sense_id, NEW.sentence_id, NEW.user_id, now()) 
      ON CONFLICT (sense_id, sentence_id) DO NOTHING;
    END IF;

  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_sentence_updates
BEFORE INSERT ON sentence_updates
FOR EACH ROW 
EXECUTE FUNCTION apply_sentence_updates();

-- Regarding Sentence deletions:
-- 1. Can delete the sentence which will remove it from all senses (the entries_view will only pull in sentences where deleted is null)
-- 2. Can delete the relationship between a sense and a sentence which will only remove it from being shown on a sense but it still exists as a sentence in the dictionary

CREATE OR REPLACE VIEW entries_view AS
SELECT
  senses.entry_id AS id,
  jsonb_agg(
    jsonb_strip_nulls(
      jsonb_build_object(
        'id', senses.id,
        'glosses', senses.glosses,
        'parts_of_speech', senses.parts_of_speech,
        'semantic_domains', senses.semantic_domains,
        'write_in_semantic_domains', senses.write_in_semantic_domains,
        'noun_class', senses.noun_class,
        'definition', senses.definition,
        'sentences', sentence_agg.sentences
      )
    )
    ORDER BY senses.created_at
  ) AS senses
FROM senses
LEFT JOIN (
  SELECT
    senses_in_sentences.sense_id,
    jsonb_agg(
      jsonb_strip_nulls(
        jsonb_build_object(
          'id', sentences.id,
          'text', sentences.text,
          'translation', sentences.translation
        )
      )
    ) AS sentences
  FROM senses_in_sentences
  JOIN sentences ON sentences.id = senses_in_sentences.sentence_id
  WHERE sentences.deleted IS NULL AND senses_in_sentences.deleted IS NULL
  GROUP BY senses_in_sentences.sense_id
) AS sentence_agg ON sentence_agg.sense_id = senses.id
WHERE senses.deleted IS NULL
GROUP BY senses.entry_id;
