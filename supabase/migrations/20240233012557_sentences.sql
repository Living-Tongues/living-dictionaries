CREATE TABLE sentences (
  id uuid unique primary key NOT NULL, -- generated on client so users can create a sentence offline and keep editing it
  "text" text,
  translation jsonb,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  created_by uuid NOT NULL REFERENCES auth.users (id),
  updated_at timestamp with time zone DEFAULT now() NOT NULL,
  updated_by uuid NOT NULL REFERENCES auth.users (id),
  deleted timestamp with time zone
);

ALTER TABLE sentences ENABLE ROW LEVEL SECURITY;

CREATE TABLE senses_in_sentences (
  sense_id uuid NOT NULL REFERENCES senses (id),
  sentence_id uuid NOT NULL REFERENCES sentences (id),
  created_by uuid NOT NULL REFERENCES auth.users (id),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  deleted timestamp with time zone,
  PRIMARY KEY (sense_id, sentence_id)
);

ALTER TABLE senses_in_sentences ENABLE ROW LEVEL SECURITY;

CREATE TYPE sentence_tables AS ENUM ('sentences', 'senses_in_sentences');
CREATE TYPE sentence_columns AS ENUM ('deleted', 'text', 'translation');

CREATE TABLE sentence_updates (
  id uuid unique primary key NOT NULL, -- generated by client via uuidv4 so it can be idempotent and they can send it multiple times without repeated effect in case of network issues
  user_id uuid NOT NULL REFERENCES auth.users (id),
  dictionary_id text NOT NULL REFERENCES dictionaries (id),
  sense_id uuid REFERENCES senses (id), -- could be null but if included the apply_sentence_updates trigger will create a sense-sentence relationship
  sentence_id uuid NOT NULL REFERENCES sentences (id),
  "timestamp" timestamp with time zone NOT NULL DEFAULT now(),
  "table" sentence_tables NOT NULL,
  "column" sentence_columns, -- could be null if just adding a new sense-sentence relationship
  new_value text, 
  old_value text
);

ALTER TABLE sentence_updates ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION temporarily_ensure_dictionary_before_apply_sentence_updates()
RETURNS TRIGGER AS $$
DECLARE
  column_data_type regtype;
  dictionary_exists boolean;
BEGIN
  INSERT INTO dictionaries (id) VALUES (NEW.dictionary_id) ON CONFLICT DO NOTHING;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER before_on_sentence_updates -- will fire before the next trigger because postgres executes triggers in alphabetical order
BEFORE INSERT ON sentence_updates
FOR EACH ROW 
EXECUTE FUNCTION temporarily_ensure_dictionary_before_apply_sentence_updates();

-- After migrating dictionaries we can run:
-- DROP TRIGGER if exists before_on_sentence_updates ON sentence_updates;
-- DROP FUNCTION if exists temporarily_ensure_dictionary_before_apply_sentence_updates();

CREATE OR REPLACE FUNCTION apply_sentence_updates()
RETURNS TRIGGER AS $$
DECLARE
  column_data_type regtype;
BEGIN
  IF NEW.table = 'sentences' THEN
  
    SELECT atttypid::regtype INTO column_data_type
    FROM pg_attribute
    WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'sentences')
      AND attname = NEW.column::text;

    EXECUTE format(
      'INSERT INTO sentences 
      (id, %I, created_by, updated_by, created_at, updated_at) 
      VALUES ($1::uuid, $2::%s, $3, $3, now(), now()) 
      ON CONFLICT (id) DO UPDATE 
      SET %I = $2::%s, updated_by = $3, updated_at = now()', 
      NEW.column,
      column_data_type,
      NEW.column,
      column_data_type
    ) USING NEW.sentence_id, NEW.new_value, NEW.user_id;

    IF NEW.sense_id IS NOT NULL THEN
      INSERT INTO senses_in_sentences -- ensure sense-sentence relationship exists
      (sense_id, sentence_id, created_by, created_at) 
      VALUES (NEW.sense_id, NEW.sentence_id, NEW.user_id, now()) 
      ON CONFLICT (sense_id, sentence_id) DO NOTHING;
    END IF;

  ELSIF NEW.table = 'senses_in_sentences' THEN -- sentence_updates only target this table if they are removing a sentence from a sense or adding sentence to additional senses

    IF NEW.column = 'deleted' THEN
      UPDATE senses_in_sentences 
      SET deleted = now() 
      WHERE sense_id = NEW.sense_id AND sentence_id = NEW.sentence_id;
    ELSE
      INSERT INTO senses_in_sentences -- add this sense to existing sentence
      (sense_id, sentence_id, created_by, created_at) 
      VALUES (NEW.sense_id, NEW.sentence_id, NEW.user_id, now()) 
      ON CONFLICT (sense_id, sentence_id) DO NOTHING;
    END IF;

  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_sentence_updates
BEFORE INSERT ON sentence_updates
FOR EACH ROW 
EXECUTE FUNCTION apply_sentence_updates();

-- Regarding Sentence deletions:
-- 1. Can delete the sentence which will remove it from all senses (the entries_view will only pull in sentences where deleted is null)
-- 2. Can delete the relationship between a sense and a sentence which will only remove it from being shown on a sense but it still exists as a sentence in the dictionary

CREATE OR REPLACE VIEW entries_view AS
SELECT
  senses.entry_id AS id,
  jsonb_agg(
    jsonb_strip_nulls(
      jsonb_build_object(
        'id', senses.id,
        'glosses', senses.glosses,
        'parts_of_speech', senses.parts_of_speech,
        'semantic_domains', senses.semantic_domains,
        'write_in_semantic_domains', senses.write_in_semantic_domains,
        'noun_class', senses.noun_class,
        'definition', senses.definition,
        'sentences', (
          SELECT jsonb_agg(
            jsonb_strip_nulls(
              jsonb_build_object(
                'id', sentences.id,
                -- the following fields can be removed from view after sentences are also loaded by client
                'text', sentences.text,
                'translation', sentences.translation
              )
            )
          )
          FROM sentences
          INNER JOIN senses_in_sentences ON sentences.id = senses_in_sentences.sentence_id
          WHERE senses_in_sentences.sense_id = senses.id AND sentences.deleted IS NULL
        )
      )
    )
    ORDER BY senses.created_at
  ) AS senses
FROM senses
LEFT JOIN senses_in_sentences ON senses.id = senses_in_sentences.sense_id
LEFT JOIN sentences ON senses_in_sentences.sentence_id = sentences.id
WHERE senses.deleted IS NULL
GROUP BY senses.entry_id;