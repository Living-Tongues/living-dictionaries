CREATE TABLE senses (
  id uuid unique primary key NOT NULL, -- generated by client via uuidv4 so users can create a sense offline and keep adding to it
  entry_id text NOT NULL, -- add REFERENCES entries (id) once Firestore data migrated
  glosses jsonb,
  parts_of_speech text[],
  semantic_domains text[],
  write_in_semantic_domains text[],
  noun_class character varying,
  definition_english_deprecated text,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  created_by text NOT NULL, -- add REFERENCES auth.users (id) once Firestore data migrated
  updated_at timestamp with time zone DEFAULT now() NOT NULL,
  updated_by text NOT NULL, -- add REFERENCES auth.users (id) once Firestore data migrated
  deleted timestamp with time zone
);

ALTER TABLE senses ENABLE ROW LEVEL SECURITY;

CREATE VIEW entries_view AS
SELECT
  entry_id as id,
  jsonb_agg(
    jsonb_strip_nulls(
      jsonb_build_object(
        'id', id,
        'glosses', glosses,
        'parts_of_speech', parts_of_speech,
        'semantic_domains', semantic_domains,
        'write_in_semantic_domains', write_in_semantic_domains,
        'noun_class', noun_class,
        'definition_english_deprecated', definition_english_deprecated
        -- 'created_at', created_at,
        -- 'created_by', created_by,
        -- 'updated_at', updated_at,
        -- 'updated_by', updated_by
      )
    )
    ORDER BY created_at
  ) AS senses
FROM senses
WHERE deleted IS NULL
GROUP BY entry_id;

CREATE TYPE entry_tables AS ENUM ('senses'); -- future: 'entry', 'audio', 'videos', 'photos', 'speakers'

CREATE TABLE entry_updates (
  id uuid unique primary key NOT NULL, -- generated by client via uuidv4 so it can be idempotent and they can send it multiple times without repeated effect in case of network issues
  user_id text NOT NULL, -- add REFERENCES auth.users (id) once Firestore data migrated and set this in a trigger once we have auth connected
  dictionary_id text NOT NULL, -- add REFERENCES dictionaries (id) once Firestore data migrated
  entry_id text NOT NULL, -- add REFERENCES entries (id) once Firestore data migrated
  "timestamp" timestamp with time zone DEFAULT now() NOT NULL,
  "table" entry_tables NOT NULL,
  "row" text NOT NULL, -- initially just the sense id, but later also entry id, photo id, etc.
  "column" text NOT NULL,
  new_value text,
  old_value text
);

ALTER TABLE entry_updates ENABLE ROW LEVEL SECURITY;

CREATE FUNCTION apply_entry_updates()
RETURNS TRIGGER AS $$
BEGIN
  EXECUTE format(
    'INSERT INTO %I 
    (id, entry_id, %I, created_at, updated_at, created_by, updated_by) 
    VALUES (%L, %L, %L, now(), now(), %L, %L) 
    ON CONFLICT (id) DO UPDATE 
    SET %I = %L, updated_at = now(), updated_by = %L', 
    NEW.table, 
    NEW.column, 
    NEW.row,
    NEW.entry_id,
    NEW.new_value,
    NEW.user_id,
    NEW.user_id,
    NEW.column, 
    NEW.new_value,
    NEW.user_id
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_entry_updates
AFTER INSERT ON entry_updates
FOR EACH ROW
EXECUTE FUNCTION apply_entry_updates();