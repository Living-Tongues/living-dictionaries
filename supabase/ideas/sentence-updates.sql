CREATE TYPE sentence_tables AS ENUM ('sentences', 'senses_in_sentences');
CREATE TYPE sentence_columns AS ENUM ('deleted', 'text', 'translation');

CREATE TABLE sentence_updates (
  id uuid unique primary key NOT NULL, -- generated by client via uuidv4 so it can be idempotent and they can send it multiple times without repeated effect in case of network issues
  user_id uuid NOT NULL REFERENCES auth.users,
  firebase_email text, -- temporary until migration complete
  dictionary_id text NOT NULL REFERENCES dictionaries,
  sentence_id uuid NOT NULL REFERENCES sentences,
  sense_id uuid REFERENCES senses, -- could be null, but if included the apply_sentence_updates trigger will create a sense-sentence relationship
  "timestamp" timestamp with time zone NOT NULL DEFAULT now(),
  "table" sentence_tables NOT NULL,
  -- all following could be null if just adding a new sense-sentence relationship using senses_in_sentences table
  "column" sentence_columns, 
  new_value text, 
  old_value text
);

ALTER TABLE sentence_updates ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION ensure_dictionary_before_apply_sentence_updates()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO dictionaries (id) VALUES (NEW.dictionary_id) ON CONFLICT DO NOTHING;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER before_on_sentence_updates_temp1 -- will fire before the next trigger because postgres executes triggers in alphabetical order
BEFORE INSERT ON sentence_updates
FOR EACH ROW 
EXECUTE FUNCTION ensure_dictionary_before_apply_sentence_updates();

-- After migrating dictionaries we can run:
-- DROP TRIGGER if exists before_on_sentence_updates_temp1 ON sentence_updates;
-- DROP FUNCTION if exists ensure_dictionary_before_apply_sentence_updates();

CREATE OR REPLACE FUNCTION convert_firebase_email_to_supabase_user_id_using_field()
RETURNS TRIGGER AS $$
DECLARE
    fetched_user_id UUID;
BEGIN
    SELECT id INTO fetched_user_id
    FROM auth.users
    WHERE email = NEW.firebase_email;

    IF fetched_user_id IS NOT NULL THEN
        NEW.user_id := fetched_user_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER before_on_sentence_updates_temp2
BEFORE INSERT ON sentence_updates
FOR EACH ROW 
EXECUTE FUNCTION convert_firebase_email_to_supabase_user_id_using_field();

CREATE OR REPLACE FUNCTION apply_sentence_updates()
RETURNS TRIGGER AS $$
DECLARE
  column_data_type regtype;
BEGIN
  IF NEW.table = 'sentences' THEN
  
    SELECT atttypid::regtype INTO column_data_type
    FROM pg_attribute
    WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'sentences')
      AND attname = NEW.column::text;

    EXECUTE format(
      'INSERT INTO sentences 
      (id, %I, created_by, updated_by, created_at, updated_at) 
      VALUES ($1::uuid, $2::%s, $3, $3, now(), now()) 
      ON CONFLICT (id) DO UPDATE 
      SET %I = $2::%s, updated_by = $3, updated_at = now()', 
      NEW.column,
      column_data_type,
      NEW.column,
      column_data_type
    ) USING NEW.sentence_id, NEW.new_value, NEW.user_id;

    IF NEW.sense_id IS NOT NULL THEN
      INSERT INTO senses_in_sentences -- ensure sense-sentence relationship exists
      (sense_id, sentence_id, created_by, created_at) 
      VALUES (NEW.sense_id, NEW.sentence_id, NEW.user_id, now()) 
      ON CONFLICT (sense_id, sentence_id) DO NOTHING;
    END IF;

  ELSIF NEW.table = 'senses_in_sentences' THEN -- sentence_updates only target this table if they are removing a sentence from a sense or adding sentence to additional senses

    IF NEW.column = 'deleted' THEN
      UPDATE senses_in_sentences 
      SET deleted = now() 
      WHERE sense_id = NEW.sense_id AND sentence_id = NEW.sentence_id;
    ELSE
      INSERT INTO senses_in_sentences -- add this sense to existing sentence
      (sense_id, sentence_id, created_by, created_at) 
      VALUES (NEW.sense_id, NEW.sentence_id, NEW.user_id, now()) 
      ON CONFLICT (sense_id, sentence_id) DO NOTHING;
    END IF;

  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_sentence_updates
BEFORE INSERT ON sentence_updates
FOR EACH ROW 
EXECUTE FUNCTION apply_sentence_updates();

-- Regarding Sentence deletions:
-- 1. Can delete the sentence which will remove it from all senses (the entries_view will only pull in sentences where deleted is null)
-- 2. Can delete the relationship between a sense and a sentence which will only remove it from being shown on a sense but it still exists as a sentence in the dictionary